<program> ::= <statement>

<digit> ::= 0
	| 1
	| 2
	| 3
	| 4
	| 5
	| 6
	| 7
	| 8
	| 9

<number> ::= <digit> <number1>
<number1> ::= // lambda
	| <number>

<sign> ::= // lambda
	| -

<int> ::= <sign> <number>

<boolean> ::= true
	| false

<lower> ::= a
	| b
	| c
	| d
	| e
	| f
	| g
	| h
	| i
	| j
	| k
	| l
	| m
	| n
	| o
	| p
	| q
	| r
	| s
	| t
	| u
	| v
	| w
	| x
	| y
	| z

<caps> ::= A
	| B
	| C
	| D
	| E
	| F
	| G
	| H
	| I
	| J
	| K
	| L
	| M
	| N
	| O
	| P
	| Q
	| R
	| S
	| T
	| U
	| V
	| W
	| X
	| Y
	| Z

<letter> ::= <lower>
	| <caps>

<alphanum> ::= // lambda
	| <alphanum1> <alphanum>
<alphanum1> ::= <letter>
	| <digit>

<string> ::= " <alphanum> "

// identifiers gather vars, arrays and global vars
<identifier> ::= $ <identifier0>
<identifier0> ::= <lower> <alphanum> <array>
	| <number> // global
<array> ::= // lambda
	| <array_list>

<array_list> ::= [ <expression> ] <array_list0>
<array_list0> ::= // lambda
	| <array_list>

<operator> ::= +
	| -
	| *
	| /
	| %

<expression0> ::= <int>
	| <identifier>
	| <string>
	| <fname> ( <expression_list> )
	| ( <expression> )
	| <lambda_expression>
<expression> ::= <expression0> <expression1>
<expression1> ::= // lambda
	| <operator> <expression>
<lambda_expression> ::= lambda ( <arg0> ) { <return> }

<expression_list> ::= <expression> <expression_list0>
<expression_list0> ::= // lambda
	| , <expression_list>

<boolean_expression> ::= <boolean>
	| <expression> <boolean_expression0>
	| ! <boolean_expression>
<boolean_expression0> ::= <comparator> <expression>
	| <boolean_operator> <expression>
	| //lambda needed for the "not"

// condition may also be for example an identifier (if handled)
<condition> ::= <boolean_expression>

<comparator> ::= <
	| >
	| >=
	| <=
	| ==
	| !=

<boolean_operator> ::= or
	| and

<arg0> ::= <identifier> <arg>
<arg> ::= // lambda
	| , <arg0>

<fname> ::= <lower> <alphanum>

<declaration> ::= <identifier> <declaration0>
<declaration0> ::= ;
	| = <expression> ;

<if> ::= if ( <condition> ) { <statement> } <if0>
<if0> ::= else { <statement> }
	| // lambda

<function> ::= function <fname> ( <arg> ) { <statement_list> <return> }

<return> ::= return <expression> ;

<statement0> ::= <declaration>
	| while ( <condition> ) { <statement> }
	| <if>
	| say ( <expression> ) ;
	| listen ( ) ;
	| <function>
	| map ( <lambda_expression> , <identifier> ) ;

<statement> ::= <statement0> <statement_list>
<statement_list> ::= // lambda
	| <statement>
